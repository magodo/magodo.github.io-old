---
layout: "post"
title: "Avoid Deadlock"
categories:
- "C"
---

<!--more-->

***
Table of Content

* TOC
{:toc}
***

下文中把 *semaphore*, *pthread mutex* 统称为 “锁”。

# 0 Thread Safe VS Reentrant

## 0.1 Thread Safe Functions

引用于 *CSAPP section 12.7.1*:

>>> Thread-safe 函数：被多个线程反复调用也可以保证正确的结果

thread unsafe 函数的类型包括：

1. Functions that do not protect shared variables
2. Functions that keep state across multiple invocations
3. Functions that return a pointer to a static variable
4. Functions that call thread-unsafe function

大部分C库的函数是thread-safe的函数。下面列举了某些的thread-unsafe函数以及它们的thread-safe版本：



## 0.2 Reentrant Functions

引用于 *CSAPP section 12.7.2*:

>>> Reentrant 函数：不会引用任何shared data（包括global variable, static local variable）的函数

引用于 *APUE section 10.6*:

>>> The Single UNIX Specification specifies the functions that are guaranteed to be safe to call from within a signal handler. These functions are reentrant and are called async-signal safe by the Single UNIX Specification. Besides being reentrant, they block any signals during operation if delivery of a signal might cause inconsistencies

SUS定义的可重入函数包括：

不在上表中的函数大致分为以下几类：

1. 使用了static data的函数
2. 调用了 `malloc` 或者 `free`
3. 标准I/O库的函数，因为大部分标准I/O库的实现都用了全局数据结构

需要注意的是，即使调用了可重入函数，`errno`还是只有一个（shared data）。所以:

1. 对于在signal handler中调用会影响到 `errno` 的函数要在调用前先保存原始的值，在调用完毕后恢复
2. 对于多线程的情况，貌似无解








# 1 多线程(带锁)

## 1.1 不同的线程对于共用的锁的上锁顺序要一致

## 1.2 使用 *thread safe*的函数
