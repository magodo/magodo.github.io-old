---
layout: "post"
title: "Avoid Deadlock"
categories:
- "C"
---

<!--more-->

***
Table of Content

* TOC
{:toc}
***

## 0 Thread Safe VS Reentrant

### 0.1 Thread Safe Functions

引用于 *CSAPP section 12.7.1*:

>>> Thread-safe 函数：被多个线程反复调用也可以保证正确的结果

thread unsafe 函数的类型包括：

1. Functions that do not protect shared variables
2. Functions that keep state across multiple invocations
3. Functions that return a pointer to a static variable
4. Functions that call thread-unsafe function

大部分C库的函数是thread-safe的函数。下面列举了某些的thread-unsafe函数以及它们的thread-safe版本：

![thread-unsafe fnctions](/images/dead-lock/thread-unsafe-functions.bmp)

### 0.2 Reentrant Functions

引用于 *CSAPP section 12.7.2*:

>>> Reentrant 函数：不会引用任何shared data（包括global variable, static local variable）的函数

引用于 *APUE section 10.6*:

>>> The Single UNIX Specification specifies the functions that are guaranteed to be safe to call from within a signal handler. These functions are reentrant and are called async-signal safe by the Single UNIX Specification. Besides being reentrant, they block any signals during operation if delivery of a signal might cause inconsistencies

SUS定义的可重入函数包括：

![reentrant-functions](/images/dead-lock/Reentrant-functions.bmp)

不在上表中的函数大致分为以下几类：

1. 使用了static data的函数
2. 调用了 `malloc` 或者 `free`
3. 标准I/O库的函数，因为大部分标准I/O库的实现都用了全局数据结构

需要注意的是，即使调用了可重入函数，程序中的 `errno` 还是只有一个，是一个shared data.所以:

1. 对于在signal handler中调用会影响到 `errno` 的函数要在调用前先保存原始的值，在调用完毕后恢复
2. 对于多线程的情况，貌似无解

### 0.3 Thread Safe VS Reentrant

引用于 *CSAPP section*

![venn diagram](/images/dead-lock/venn.png)


## 1 多线程(带锁)

注意，这里的“锁”指代各种形式，包括：semaphore, thread mutex,...

### 1.1 不同的线程对于共用的锁的上锁顺序要一致

### 1.2 线程中使用 thread safe 的函数

## 2 多线程（带锁）+ 信号处理函数（带锁）

注意，这里的“锁”指代各种形式，包括：semaphore, thread mutex,...

### 2.1 不同的线程对于共用的锁的上锁顺序要一致

### 2.2 线程中使用 thread safe 的函数

### 2.3 信号处理函数中使用reentrant函数

### 2.4 同一个线程不要连续lock同一个锁

听起来比较不太可能犯的错误，在多线程与信号结合的情景下就可能发生。例如：

1. 问题：
对于一个信号的情况，可能被信号占用的线程， **信号处理函数** 中用到的锁和 **线程入口函数** 中用到的锁一样的时候，可能会死锁

    举例：线程在lock mutex1的之后，unlock之前，被信号中断并占用当前线程，如果此时在信号处理函数中再次lock mutex1，就会死锁。 

    解决：

    * **线程入口函数** 不要有锁的操作

        * 例如，起一个专门的线程去处理这个信号，在这个线程的入口函数中执行简单的wait操作(例如：`sigwait()`, `sleep()`,...)

    * **信号处理函数** 中不要有锁的操作
    * **线程入口函数** 和 **信号处理函数** 中没有共用的锁

2. 问题：对于多个信号的情况，可能被多个信号同时占用的线程，即使 **线程入口函数** 没有用锁，如果不同信号的 **信号处理函数** 用到同一个锁，也可能死锁

    举例：线程在执行过程中，被SIG1中断并占用，SIG1的信号处理函数代码中lock mutex1，在mutex1被unlock之前，该线程被SIG2中断并占用，SIG2的信号处理函数代码中也lock了mutex1，就会死锁。这种情况典型的发行情景是，有一个专门的线程调用 `sigwait()` 等待中断（其他线程都BLOCK了相关的信号），当中断来了之后会去执行不同的信号处理函数。这种情况下，由于由多个信号处理函数在同一个线程里执行，因此有可能发生上述情况。

    解决：

    * **线程入口函数** 不要有锁的操作

       * 例如，如果多个信号需要同时被等待，那么就起多个线程去处理不同的信号（每个线程除自己等待的信号外，BLOCK其他信号），在这些线程的入口函数中执行简单的wait操作(例如：`sigwait()`, `sleep()`,...)

    * **信号处理函数** 中不要由锁的操作
    * **线程入口函数** 和 不同信号的 **信号处理函数** 中没有共用的锁

## 3 注意

1. 项目中用到的第三方库函数，要考虑到它们是否 **线程安全** ，如果线程安全，才可以用于多线程的情况
2. 项目中用到的第三方库函数，要考虑到它们是否 **可重入** ，如果不可重入，则避免在信号处理函数中使用
3. 项目中用到的第三方库函数，要考虑到它们是否能在内部实现中有加锁/解锁操作（例如为了保证线程安全而加入的）。如果存在锁操作，则要考虑 "2.4节"中的情况（如果无法查看源码，则根据最不利原则，应该假定它们是存在锁操作的）
