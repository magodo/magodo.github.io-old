---
layout: "post"
title: "ALSA - PCM接口"
categories:
- "alsa"
---

<!--more-->

***
Table of Content

* TOC
{:toc}
***

*本文大部分内容纯属个人基于ALSA官网的"[PCM Interface](http://www.alsa-project.org/alsa-doc/alsa-lib/pcm.html)"的理解，如有理解错误的地方，欢迎[邮件](wztwcy@gmail.com)告诉我 :)*

# 0. PCM

**Pulse-code modulation(PCM)**

将模拟信号表示为数字信号的一种方法，它是计算机,CD,数字电话以及其他数字音频设备对数字音频信号的标准表示法。在一个PCM流当中，模拟信号是按照一定间隔（采样周期）进行采集，每个采样点的采样值则被近似地量化为最接近的一个值（由采样深度决定）。

**Linear pulse-code-modulation(LPCM)**

PCM中的一种类型，这种类型的量化值与模拟信号强度（响度）是呈线性关系。

**Non-linear pulse-code-modulation**

LPCM中的一种类型PCM不同，它的量化值相对与模拟信号强度呈非线性关系。例如：u-law, A-law等。

一个PCM流的质量取决与两方面：

* **采样频率** 
* **采样深度(bit depth)**

在ALSA的PCM接口当中，PCM泛指所有离散时间内的离散采样音频信号。


# 1. 概述

## 1.1 PCM设备的两种类型

PCM设备（内核level）可以简单地分为"输出(playback)"和"输入(capture)"两类。其中的方向是站在ALSA应用的角度而言，即：

* PCM输出设备接收从ALSA应用传入的数据，再到mixer(CTL设备)，然后路由至输出socket,外接的物理声卡设备(或者路由到别的PCM输入设备)
* PCM输入设备将数据通过socket从物理声卡设备（或者经由mixer从别的PCM输出设备）读入，传入ALSA应用

  (注意：这里的*PCM输入/输出设备*指的是ALSA中的逻辑设备，它可以是物理的声卡设备，也可以是Plugin)

## 1.2 PCM设备和ALSA应用的ring buffer

具体参见[这里](http://www.linuxjournal.com/node/6735/print)

声卡设备在硬件层面有一个ring buffer，同时在alsa的kernel space，也维护一个ring buffer：

* __playback__ 当ALSA设备进入RUNNING状态，每当声卡传出一个period之后(花费1个period_time的时间)，会向kernel发送硬件中断，于是kernel将另一个period的数据由自身维护的ring buffer传输至硬件声卡的buffer(瞬间);
* __capture__ 当ALSA设备进入RUNNING状态，声卡设备会不断地采集到数据，每采集一个period的数据后，声卡设备会发送硬件中断到kernel，kernel将数据由硬件buffer传输至自己维护的ring buffer中.

如下图所示：

![ALSA_Periods](/images/alsa/pcm/Period.png)


作为alsa lib用户，我们只需要关心alsa-lib中的ring buffer。它由两个指针维护:

1. 对于 playback:
  * 当前硬件正在读的sample (START)
  * 上一次应用程序写的sample (END)
2. 对于 capture:
  * 当前硬件正在写的sample (END)
  * 上一次应用程序读的sample (START)

(参考Wiki-[ring buffer](https://en.wikipedia.org/wiki/Circular_buffer))

### 1.2.1 ring buffer - 单位(period, frame, sample)

buffer的size可以通过ALSA library的API进行修改。如果buffer设的太大，那么一次数据的传输需要的延迟会增加。为了解决这个问题，ALSA将buffer分为一系列的**period**(在OSS/Free语境中称为fragment)，然后以period为单位进行数据的传输。

因此，在buffer里有以下几个单位：

* **period** 一个period当中存储多个多个frame
* **frame** 一个frame中存储一个或多个同一时间采集的sample。多个ADC/DAC用于同一时间采集/转换多个sample，那么这几个同时间被处理的sample组成一个frame。通常，如果一个设别有N个channel，那么它的一个frame等于N个sample
* **sample** 每一个采样得到的数值称为一个sample，它可能是多个字节的，大端或者小端，浮点数或者整数，有符号或者无符号

它们的关系如下图所示：

![ALSA application buffer](/images/alsa/pcm/alsa_app_buffer_i.png)

### 1.2.2 ring buffer - 访问方式(interleaved, non-interleaved)

Ring buffer 有三种访问方式：

1. **Interleaved access**
   
        C0 C1 C2 C3 C0 C1 C2 C3 ....

2. **Non-interleaved access**

        C0 C0 C0 C0 ................ C1 C1 C1 C1 ............. C2 C2 C2 C2 ............... C3 C3 C3 C3 ...........
  注意：对于这种访问模式，每个通道有单独的ring buffer!

3. **Complex access**

具体参见 [PCM Ring Buffer](http://www.alsa-project.org/main/index.php/PCM_Ring_Buffer)



# 2. ALSA 设备打开 和 数据传输

# 2.1 阻塞和非阻塞打开设备

PCM设备可以以阻塞或非阻塞两种模式打开：


1. 打开设备时，如果该设备当前正在被其他应用使用：

  * 阻塞：则调用的进程会被阻塞
  * 非阻塞：立即返回 `-EBUSY`给调用进程


2. 打开设备的mode也会影响到它的标准I/O数据传输。当应用调用PCM API对该设备进行操作（例如: playback/capture）如果该设备没被其他应用使用，但是ring buffer为满（对于playback）/空（对于capture）：

  * 阻塞：则调用进程会被阻塞
  * 非阻塞：立即返回 `-EAGAIN`给调用进程

  该阻塞模式模式可以通过`snd_pcm_nonblock`函数改变。

# 2.2 数据传输

# 2.2.1 读写传输(read/write)

可以用于传输interleaved/non-interleaved的数据，并且有阻塞和非阻塞两种模式

# 2.2.2 直接读写传输(mmap)

可以用于传输interleaved/non-interleaved/complex的数据。应用程序的调用顺序如下：

1. `snd_pcm_avail_update()`: 获得当前ready的frame数(读/写). 其中，playback表示ring buffer中空余的空间(frame); capture表示ring buffer中有效的数据数(frame). 特别地，对于capture，为application层的数据传输做好准备
2. `snd_pcm_mmap_begin()`: 获得一片一定大小的内存，这片区域内是当前可被读取(capture)/可用于写入(playback)
3. `snd_pcm_mmap_commit()`: 告诉alsa driver之前那片区域已经被读取(capture)/写入(playback),将那片内存标记为not ready

# 2.2.2.1 snd_pcm_avail_update vs snd_pcm_avail





# 3. ALSA应用能看到的PCM设备状态迁移图

调用`snd_pcm_state`可以获取当前PCM设备的状态

### SND_PCM_STATE_OPEN

表示PCM设备处于打开状态。

进入原因：

1. `snd_pcm_open`调用成功
2. `snd_pcm_hw_params`调用失败，目的是强制ALSA应用设置正确的硬件参数


### SND_PCM_STATE_SETUP

表示PCM设备已经被正确地设置了硬件参数。此时，它正在等到`snd_pcm_prepare`来使设备对设置的操作（playback/capture）做准备。

进入原因：

1. `snd_pcm_hw_params`调用成功
2. `snd_pcm_drop`

### SND_PCM_STATE_PREPARED

表示设备已经就绪。此时，ALSA应用可以调用`snd_pcm_start`，读或者写来进行操作。

进入原因：

1. `snd_pcm_prepare`调用成功

### SND_PCM_STATE_RUNNING

表示设备正在操作，即正在处理采样的数据。这个过程可以被`snd_pcm_drop`或`snd_pcm_drain`停止。

进入原因：

1. `snd_pcm_start`调用成功
2. 操作为playback，并且ALSA应用写入PCM设备ring buffer的frame超过了软件参数中设置的*start threshold*
3. 操作为capture，并且PCM设备ring buffer的frame超过了软件参数中设置的*start threshold*

### SND_PCM_STATE_XRUN

表示设备overrun(capture)或者underrun(playback). 其中，前者表示ALSA应用没有及时将PCM设备的ring buffer中的数据读走，导致ring buffer满了；后者表示ALSA应用没有及时往PCM设备ring buffer里传数据，导致ring buffer空了。

进入这种情况后，建议调用`snd_pcm_recover`来恢复，也可以通过`snd_pcm_prepare`/`snd_pcm_drop`/`snd_pcm_drain`来离开此状态

进入原因：

1. *overrun*/*underrun*发生
2. PCM设备buffer中的frame数小于*stop threshold*

### SND_PCM_STATE_DRAINING

表示capture设备正在等待ALSA应用将ring buffer中的数据读走。

对于playback模式的设备调用了`snd_pcm_drain`是不会进入这个状态的。

进入原因：

1. 设备为capture模式，并且调用了`snd_pcm_drain`

### SND_PCM_STATE_PAUSED

表示支持pause（可以通过`snd_pcm_hw_params_can_pause`来确定）的设备处于停止状态。

进入原因：

1. 支持pause的设备调用`snd_pcm_pause`

### SND_PCM_STATE_SUSPENDED

表示由于电源管理系统，使设备进入一种挂起状态。

对于支持resume的设备，建议调用`snd_pcm_resume`来离开该状态，直接进入*SND_PCM_STATE_PREPARE*状态（可以调用`snd_pcm_hw_params_can_resume`来确定）。对于不支持resume的设备，可以调用`snd_pcm_prepare`/`snd_pcm_drop`/`snd_pcm_drain`来离开该状态。

进入原因：

1. 设备由于电源管理系统而进入该状态

### SND_PCM_STATE_DISCONNECTED

表示设备不再连接系统，该状态下不再接受任何I/O调用。

### 不完整的状态迁移图

![ALSA PCM stream FSM](/images/alsa/pcm/StateDiagram.png)


# 4. 错误码

1. -EPIPE
  表示设备处于 _xrun_ (underrun for playback or overrun for capture).

2. -ESTRPIPE
  表示设备处于 _suspended_. 这时候需要循环调用`snd_pcm_resume()` 直到它返回非-EAGAIN的error( _setup_ )或者0 ( _prepare_ ).

3. -EBADFD
  表示设备处于一个错误的状态，这意味着应用和alsa lib之间的握手协议已经错乱了.

4. -ENOTTY, -ENODEV
  表示设备已经被物理地移除了.

# 5. HW/SW 参数

## 5.1 HW 参数

ALSA PCM设备对于硬件参数，使用了一种"逐步限制"的机制(refinement system) - `snd_pcm_hw_params_t`. 应用程序在一开始设定所有支持的HW参数空间，然后通过设置其中的某几个参数为定值，直到其他参数都被限定为止。最后，将设定好了的参数空间install给该设备(`snd_pcm_hw_params`)。之后，HW参数就不得再改变了。

对于某个HW参数，会有以下几种形式的API可供使用：

    snd_pcm_hw_params_get_xxx: 获得某个硬件参数的大约值。有些API中带dir参数(out)，文档中说是表明实际的硬件参数值与该大约值的大小关系，但是实际测试发现该值不是0就是1，所以建议在get的API中不要依赖该值； 
    snd_pcm_hw_params_set_xxx: 设置某个硬件参数，如果当前硬件在当前的参数空间设置下不支持该值，则设置的实际值会与期望值不同。dir(in),用于指定当期望值不被支持的时候，硬件会选用比该值小的实际值还是大的实际值。(期望值 --(dir)--> 实际值)
    snd_pcm_hw_params_set_xxx_near: 设置某个硬件参数，如果当前硬件在当前的参数空间设置下不支持该值，则设置的实际值会与期望值不同。dir(in),用于指定当期望值不被支持的时候，会选用比该值小的实际值还是大的实际值。同时，实际被设置的值也会被转换为大约值传出来，这个大约值可能由于类型关系而于实际值有所区别(例如rate的实际值是个浮点数，而大约值却是个ulong)。(期望值 --(dir)--> 实际值 --(round)--> 大约值)

                                    注意：有时候并不是完全这样的，例如在我的环境下如果设置rate为5005，会有以下结果：

                                    set_dir         expect          actual      approx
                                    1               5005            5004.x      5005
                                    -1              5005            5005.x      5004

                                    这正好相反...(黑人问号脸) 所以这个dir参数还是不用为妙！

   				             
    snd_pcm_hw_params_test_xxx: 测试在硬件的当前参数空间内，某个硬件参数是否可以被设置
    snd_pcm_hw_params_can_xxx: 测试当前硬件是否支持某种功能

### 5.2 rate/buffer/period的单位

rate的单位是 frame/s
period time 的单位是us
period size 的单位是frame
period bytes的单位是byte

buffer time 的单位是us
buffer size 的单位是frame
buffer bytes的单位是byte

### 5.3 periods vs buffer size vs buffer time

1. buffer size/time指定了ring buffer的大小，它一定是period size/time的整数倍；
2. periods实际也是用于指定buffer的大小的.

额外地，如果指定了periods而没有指定buffer size，则实际的buffer size将会位于:\[periods*period\_size, buffer\_size max\]


## 5.2 SW 参数

软件参数可以在任意时刻修改，包括RUNNING状态。

# 6. STREAM状态

这里的流的状态(status)不同于上面所提到PCM设备的状态(`snd_pcm_state`), 通过`snd_pcm_status_get_state`返回的`snd_pcm_status_t`结构体记录。其中包括：

1. timestamp of trigger: `snd_pcm_status_get_trigger_tstamp()`
2. timestamp of last pointer update: `snd_pcm_status_get_tstamp()`
3. delay(sample): `snd_pcm_status_get_delay()`
4. available count(sample): `snd_pcm_status_get_avail()`
5. maximum available samples: `snd_pcm_status_get_avail_max()`
6. ADC over-range count(sample): `snd_pcm_status_get_overrange()`

## 6.1 获得stream状态，更新r/w指针

# 7. STREAM同步

# 8. PCM 命名规范

# 引用

[1] [PCM interface](http://www.alsa-project.org/alsa-doc/alsa-lib/pcm.html)

[2] [Introduction to Sound Programming with ALSA](http://www.linuxjournal.com/node/6735/print)

[3] [PCM Ring Buffer](http://www.alsa-project.org/main/index.php/PCM_Ring_Buffer)

[4] [A close look at ALSA](http://www.volkerschatz.com/noise/alsa.html)

[5] [Linux AlSA sound notes](http://www.sabi.co.uk/Notes/linuxSoundALSA.html)
